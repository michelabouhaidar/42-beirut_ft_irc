/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 12:47:36 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/04 17:05:25 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CHANNEL_HPP
#define CHANNEL_HPP

#include <string>
#include <set>

class Channel
{
	public:
		std::string name;
		std::string topic;
		std::set<int> members;
		std::set<int> operators;
		std::set<int> invited;

		bool modeInviteOnly;
		bool modeTopicOpOnly;
		bool modeKey;
		std::string key;
		bool modeLimit;
		int userLimit;

		Channel();
		Channel(const std::string &name_);

		bool isMember(int fd) const;
		bool isOp(int fd) const;

		void addMember(int fd);
		void removeMember(int fd);

		bool isFull() const;
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 12:43:03 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:16:18 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef CLIENT_HPP
#define CLIENT_HPP

#include <string>
#include <set>

class Client
{
	public:
		int fd;
		std::string host;

		std::string inbuf;
		std::string outbuf;

		bool passOk;
		bool hasNick;
		bool hasUser;
		bool registered;

		std::string nick;
		std::string user;

		std::set<std::string> channels;

		Client();
		Client(int fd_, const std::string &host_);

		void queue(const std::string &data);
		bool wantsWrite() const;
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Handlers.hpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 12:54:52 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/04 16:55:40 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef HANDLERS_HPP
#define HANDLERS_HPP

#include "Server.hpp"
#include "Message.hpp"

void handleCommand(Server &srv, int fd, const Message &msg);

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Message.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 12:38:59 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/04 17:04:31 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MESSAGE_HPP
#define MESSAGE_HPP

#include <string>
#include <vector>

class Message
{
	public:
		std::string raw;
		std::string command;
		std::vector<std::string> params;
		std::string trailing;
		bool hasTrailing;

		Message();

		static Message parse(const std::string &line);

	private:
		static std::string trim(const std::string &s);
		static std::string toUpper(const std::string &s);
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 12:52:19 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:43:08 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef SERVER_HPP
#define SERVER_HPP

#include <string>
#include <map>
#include <vector>
#include <poll.h>

#include "Client.hpp"
#include "Message.hpp"
#include "Channel.hpp"

class Server
{
	public:
		Server(int port, const std::string &password);
		~Server();

		void run();

		void sendToClient(int fd, const std::string &msg);
		void sendNumeric(int fd, int code, const std::string &target, const std::string &text);
		void broadcastToChannel(const std::string &chan, int exceptFd, const std::string &msg);

		bool nickExists(const std::string &nick) const;
		int fdByNick(const std::string &nick) const;

		Client *getClient(int fd);
		Channel *getChannel(const std::string &name);

		Channel *getOrCreateChannel(const std::string &name);
		void eraseChannel(const std::string &name);

		const std::string& getPassword() const;
		const std::string& getServerName() const;

		void disconnectClient(int fd, const std::string &reason);

	private:
		int port_;
		std::string password_;

		int listenFd_;
		bool running_;

		std::string serverName_;
		std::map<int, Client> clients_;
		std::map<std::string, Channel> channels_;

		void setupListenSocket();
		void setNonBlocking(int fd);
		void buildPollFds(std::vector<struct pollfd> &pfds);

		void handleAccept();
		void handleClientRead(int fd);
		void handleClientWrite(int fd);

		void processLine(int fd, const std::string &line);
};

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Channel.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:25 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:24:59 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Channel.hpp"

Channel::Channel()
	: name(""), topic(""),
	modeInviteOnly(false), modeTopicOpOnly(false),
	modeKey(false), key(""),
	modeLimit(false), userLimit(0) {}

Channel::Channel(const std::string &name_)
	: name(name_), topic(""),
	modeInviteOnly(false), modeTopicOpOnly(false),
	modeKey(false), key(""),
	modeLimit(false), userLimit(0) {}

bool Channel::isMember(int fd) const
{
	return members.find(fd) != members.end();
}

bool Channel::isOp(int fd) const
{
	return operators.find(fd) != operators.end();
}

void Channel::addMember(int fd)
{
	members.insert(fd);
}

void Channel::removeMember(int fd)
{
	members.erase(fd);
	operators.erase(fd);
	invited.erase(fd);
}

bool Channel::isFull() const
{
	if (!modeLimit) return false;
	return (int)members.size() >= userLimit;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Client.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:27 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:17:19 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Client.hpp"

Client::Client()
	: fd(-1),
	host(""),
	passOk(false),
	hasNick(false),
	hasUser(false),
	registered(false) {}

Client::Client(int fd_, const std::string &host_)
	: fd(fd_), host(host_),
	  passOk(false), hasNick(false), hasUser(false), registered(false) {}

void Client::queue(const std::string &data)
{
	outbuf += data;
}

bool Client::wantsWrite() const
{
	return !outbuf.empty();
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Handlers.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:30 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/08 20:16:29 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Handlers.hpp"
#include <sstream>
#include <cstdlib>

static std::string prefixOf(Server &srv, int fd)
{
	Client *c = srv.getClient(fd);
	if (!c) 
		return ":unknown";
	std::string n = c->hasNick ? c->nick : "*";
	std::string u = c->hasUser ? c->user : "user";
	return ":" + n + "!" + u + "@" + c->host;
}

static bool ensureRegistered(Server &srv, int fd)
{
	Client *c = srv.getClient(fd);
	if (!c) return false;
	if (!c->registered)
	{
		srv.sendNumeric(fd, 451, "*", "You have not registered");
		return false;
	}
	return true;
}

static void tryWelcome(Server &srv, int fd)
{
	Client *c = srv.getClient(fd);
	if (!c) return;

	if (!c->registered && c->passOk && c->hasNick && c->hasUser)
	{
		c->registered = true;
		srv.sendNumeric(fd, 1, c->nick, "Welcome to the IRC server " + c->nick);
		srv.sendNumeric(fd, 2, c->nick, "Your host is " + srv.getServerName());
		srv.sendNumeric(fd, 3, c->nick, "This server was created for the project");
	}
}

static void sendNames(Server &srv, int fd, const std::string &chan)
{
	Client *c = srv.getClient(fd);
	Channel *ch = srv.getChannel(chan);
	if (!c || !ch) return;

	std::string names;
	for (std::set<int>::iterator it = ch->members.begin(); it != ch->members.end(); ++it)
	{
		Client *m = srv.getClient(*it);
		if (!m || !m->hasNick) continue;

		std::string one = m->nick;
		if (ch->isOp(*it))
			one = "@" + one;

		if (!names.empty()) names += " ";
		names += one;
	}

	// 353 RPL_NAMREPLY, 366 RPL_ENDOFNAMES
	srv.sendNumeric(fd, 353, c->nick, "= " + chan + " :" + names);
	srv.sendNumeric(fd, 366, c->nick, chan + " :End of /NAMES list");
}

static void cmdPASS(Server &srv, int fd, const Message &msg)
{
	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, "*", "PASS :Not enough parameters");
		return;
	}
	if (c->registered)
	{
		srv.sendNumeric(fd, 462, c->nick, "You may not reregister");
		return;
	}

	if (msg.params[0] == srv.getPassword())
		c->passOk = true;
	else
	{
		srv.sendNumeric(fd, 464, "*", "Password incorrect");
		srv.disconnectClient(fd, "Bad password");
	}
}

static void cmdNICK(Server &srv, int fd, const Message &msg)
{
	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 431, "*", "No nickname given");
		return;
	}

	std::string newNick = msg.params[0];

	if (newNick.empty() || newNick.find(' ') != std::string::npos)
	{
		srv.sendNumeric(fd, 432, "*", "Erroneous nickname");
		return;
	}

	if (srv.nickExists(newNick) && (!c->hasNick || c->nick != newNick))
	{
		srv.sendNumeric(fd, 433, "*", "Nickname is already in use");
		return;
	}

	if (c->hasNick && c->nick != newNick)
	{
		std::string line = prefixOf(srv, fd) + " NICK :" + newNick + "\r\n";
		for (std::set<std::string>::iterator it = c->channels.begin(); it != c->channels.end(); ++it)
			srv.broadcastToChannel(*it, -1, line);
	}

	c->nick = newNick;
	c->hasNick = true;

	tryWelcome(srv, fd);
}

static void cmdUSER(Server &srv, int fd, const Message &msg)
{
	Client *c = srv.getClient(fd);
	if (!c) return;

	if (c->registered)
	{
		srv.sendNumeric(fd, 462, c->nick, "You may not reregister");
		return;
	}

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, "*", "USER :Not enough parameters");
		return;
	}

	c->user = msg.params[0];
	c->hasUser = true;

	tryWelcome(srv, fd);
}

static void cmdPING(Server &srv, int fd, const Message &msg)
{
	std::string token;
	if (!msg.params.empty())
		token = msg.params[0];
	else if (msg.hasTrailing)
		token = msg.trailing;
	else
		token = "0";

	srv.sendToClient(fd, ":" + srv.getServerName() + " PONG " + srv.getServerName() + " :" + token + "\r\n");
}

static void cmdCAP(Server &srv, int fd, const Message &msg)
{
	(void)srv; (void)fd; (void)msg;
}

static void cmdJOIN(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, c->nick, "JOIN :Not enough parameters");
		return;
	}

	std::string chname = msg.params[0];
	if (chname.empty() || chname[0] != '#')
	{
		srv.sendNumeric(fd, 479, c->nick, "Illegal channel name");
		return;
	}

	std::string providedKey;
	if (msg.params.size() >= 2)
		providedKey = msg.params[1];

	Channel *ch = srv.getOrCreateChannel(chname);

	if (ch->isMember(fd))
		return;

	if (ch->modeInviteOnly && ch->invited.find(fd) == ch->invited.end())
	{
		srv.sendNumeric(fd, 473, c->nick, chname + " :Cannot join channel (+i)");
		return;
	}
	if (ch->modeKey && ch->key != providedKey)
	{
		srv.sendNumeric(fd, 475, c->nick, chname + " :Cannot join channel (+k)");
		return;
	}
	if (ch->isFull())
	{
		srv.sendNumeric(fd, 471, c->nick, chname + " :Cannot join channel (+l)");
		return;
	}

	ch->addMember(fd);
	ch->invited.erase(fd);
	c->channels.insert(chname);

	if (ch->operators.empty())
		ch->operators.insert(fd);

	std::string joinLine = prefixOf(srv, fd) + " JOIN :" + chname + "\r\n";
	srv.broadcastToChannel(chname, -1, joinLine);

	if (ch->topic.empty())
		srv.sendNumeric(fd, 331, c->nick, chname + " :No topic is set");
	else
		srv.sendNumeric(fd, 332, c->nick, chname + " :" + ch->topic);

	sendNames(srv, fd, chname);
}

static void cmdPART(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, c->nick, "PART :Not enough parameters");
		return;
	}

	std::string chname = msg.params[0];
	Channel *ch = srv.getChannel(chname);
	if (!ch)
	{
		srv.sendNumeric(fd, 403, c->nick, chname + " :No such channel");
		return;
	}
	if (!ch->isMember(fd))
	{
		srv.sendNumeric(fd, 442, c->nick, chname + " :You're not on that channel");
		return;
	}

	std::string reason = msg.hasTrailing ? msg.trailing : "";
	std::string line = prefixOf(srv, fd) + " PART " + chname;
	if (!reason.empty()) line += " :" + reason;
	line += "\r\n";

	srv.broadcastToChannel(chname, -1, line);

	ch->removeMember(fd);
	c->channels.erase(chname);

	if (ch->members.empty())
		srv.eraseChannel(chname);
}

static void cmdTOPIC(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, c->nick, "TOPIC :Not enough parameters");
		return;
	}

	std::string chname = msg.params[0];
	Channel *ch = srv.getChannel(chname);
	if (!ch)
	{
		srv.sendNumeric(fd, 403, c->nick, chname + " :No such channel");
		return;
	}
	if (!ch->isMember(fd))
	{
		srv.sendNumeric(fd, 442, c->nick, chname + " :You're not on that channel");
		return;
	}
	if (!msg.hasTrailing)
	{
		if (ch->topic.empty())
			srv.sendNumeric(fd, 331, c->nick, chname + " :No topic is set");
		else
			srv.sendNumeric(fd, 332, c->nick, chname + " :" + ch->topic);
		return;
	}
	if (ch->modeTopicOpOnly && !ch->isOp(fd))
	{
		srv.sendNumeric(fd, 482, c->nick, chname + " :You're not channel operator");
		return;
	}

	ch->topic = msg.trailing;
	std::string line = prefixOf(srv, fd) + " TOPIC " + chname + " :" + ch->topic + "\r\n";
	srv.broadcastToChannel(chname, -1, line);
}

static void cmdINVITE(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 2)
	{
		srv.sendNumeric(fd, 461, c->nick, "INVITE :Not enough parameters");
		return;
	}

	std::string nick = msg.params[0];
	std::string chname = msg.params[1];

	int tfd = srv.fdByNick(nick);
	if (tfd < 0)
	{
		srv.sendNumeric(fd, 401, c->nick, nick + " :No such nick");
		return;
	}

	Channel *ch = srv.getChannel(chname);
	if (!ch)
	{
		srv.sendNumeric(fd, 403, c->nick, chname + " :No such channel");
		return;
	}
	if (!ch->isMember(fd))
	{
		srv.sendNumeric(fd, 442, c->nick, chname + " :You're not on that channel");
		return;
	}
	if (ch->modeInviteOnly && !ch->isOp(fd))
	{
		srv.sendNumeric(fd, 482, c->nick, chname + " :You're not channel operator");
		return;
	}

	if (ch->isMember(tfd))
	{
		srv.sendNumeric(fd, 443, c->nick, nick + " " + chname + " :is already on channel");
		return;
	}

	ch->invited.insert(tfd);

	srv.sendNumeric(fd, 341, c->nick, nick + " " + chname);

	std::string line = prefixOf(srv, fd) + " INVITE " + nick + " :" + chname + "\r\n";
	srv.sendToClient(tfd, line);
}

static void cmdKICK(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 2)
	{
		srv.sendNumeric(fd, 461, c->nick, "KICK :Not enough parameters");
		return;
	}

	std::string chname = msg.params[0];
	std::string nick = msg.params[1];
	std::string reason = msg.hasTrailing ? msg.trailing : "Kicked";

	Channel *ch = srv.getChannel(chname);
	if (!ch)
	{
		srv.sendNumeric(fd, 403, c->nick, chname + " :No such channel");
		return;
	}
	if (!ch->isMember(fd))
	{
		srv.sendNumeric(fd, 442, c->nick, chname + " :You're not on that channel");
		return;
	}
	if (!ch->isOp(fd))
	{
		srv.sendNumeric(fd, 482, c->nick, chname + " :You're not channel operator");
		return;
	}

	int tfd = srv.fdByNick(nick);
	if (tfd < 0)
	{
		srv.sendNumeric(fd, 401, c->nick, nick + " :No such nick");
		return;
	}
	if (!ch->isMember(tfd))
	{
		srv.sendNumeric(fd, 441, c->nick, nick + " " + chname + " :They aren't on that channel");
		return;
	}

	std::string line = prefixOf(srv, fd) + " KICK " + chname + " " + nick + " :" + reason + "\r\n";
	srv.broadcastToChannel(chname, -1, line);

	Client *tc = srv.getClient(tfd);
	if (tc) tc->channels.erase(chname);

	ch->removeMember(tfd);

	if (ch->members.empty())
		srv.eraseChannel(chname);
}

static void cmdMODE(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1)
	{
		srv.sendNumeric(fd, 461, c->nick, "MODE :Not enough parameters");
		return;
	}

	std::string target = msg.params[0];
	if (target.empty() || target[0] != '#')
	{
		srv.sendNumeric(fd, 501, c->nick, "Unknown MODE flag");
		return;
	}

	Channel *ch = srv.getChannel(target);
	if (!ch)
	{
		srv.sendNumeric(fd, 403, c->nick, target + " :No such channel");
		return;
	}

	if (msg.params.size() == 1)
	{
		std::string modes = "+";
		if (ch->modeInviteOnly) modes += "i";
		if (ch->modeTopicOpOnly) modes += "t";
		if (ch->modeKey) modes += "k";
		if (ch->modeLimit) modes += "l";
		srv.sendNumeric(fd, 324, c->nick, target + " " + modes);
		return;
	}

	if (!ch->isMember(fd))
	{
		srv.sendNumeric(fd, 442, c->nick, target + " :You're not on that channel");
		return;
	}
	if (!ch->isOp(fd))
	{
		srv.sendNumeric(fd, 482, c->nick, target + " :You're not channel operator");
		return;
	}

	std::string modeStr = msg.params[1];
	bool adding = true;
	size_t argi = 2;

	std::string announceParams;

	for (size_t i = 0; i < modeStr.size(); ++i)
	{
		char chm = modeStr[i];
		if (chm == '+') { adding = true; continue; }
		if (chm == '-') { adding = false; continue; }

		if (chm == 'i') ch->modeInviteOnly = adding;
		else if (chm == 't') ch->modeTopicOpOnly = adding;
		else if (chm == 'k')
		{
			if (adding)
			{
				if (msg.params.size() <= argi) { srv.sendNumeric(fd, 461, c->nick, "MODE :Not enough parameters"); return; }
				ch->modeKey = true;
				ch->key = msg.params[argi++];
				announceParams += " " + ch->key;
			}
			else
			{
				ch->modeKey = false;
				ch->key = "";
			}
		}
		else if (chm == 'l')
		{
			if (adding)
			{
				if (msg.params.size() <= argi) { srv.sendNumeric(fd, 461, c->nick, "MODE :Not enough parameters"); return; }
				ch->modeLimit = true;
				ch->userLimit = std::atoi(msg.params[argi].c_str());
				announceParams += " " + msg.params[argi];
				argi++;
			}
			else
			{
				ch->modeLimit = false;
				ch->userLimit = 0;
			}
		}
		else if (chm == 'o')
		{
			if (msg.params.size() <= argi) { srv.sendNumeric(fd, 461, c->nick, "MODE :Not enough parameters"); return; }
			std::string nick = msg.params[argi++];
			int tfd = srv.fdByNick(nick);
			if (tfd < 0) { srv.sendNumeric(fd, 401, c->nick, nick + " :No such nick"); return; }
			if (!ch->isMember(tfd)) { srv.sendNumeric(fd, 441, c->nick, nick + " " + target + " :They aren't on that channel"); return; }

			if (adding) ch->operators.insert(tfd);
			else ch->operators.erase(tfd);

			announceParams += " " + nick;
		}
		else
		{
			srv.sendNumeric(fd, 501, c->nick, "Unknown MODE flag");
			return;
		}
	}

	std::string line = prefixOf(srv, fd) + " MODE " + target + " " + modeStr + announceParams + "\r\n";
	srv.broadcastToChannel(target, -1, line);
}

static void cmdPRIVMSG(Server &srv, int fd, const Message &msg)
{
	if (!ensureRegistered(srv, fd)) return;

	Client *c = srv.getClient(fd);
	if (!c) return;

	if (msg.params.size() < 1 || !msg.hasTrailing)
	{
		srv.sendNumeric(fd, 461, c->nick, "PRIVMSG :Not enough parameters");
		return;
	}

	std::string target = msg.params[0];
	std::string text = msg.trailing;

	std::string line = prefixOf(srv, fd) + " PRIVMSG " + target + " :" + text + "\r\n";

	if (!target.empty() && target[0] == '#')
	{
		Channel *ch = srv.getChannel(target);
		if (!ch)
		{
			srv.sendNumeric(fd, 403, c->nick, target + " :No such channel");
			return;
		}
		if (!ch->isMember(fd))
		{
			srv.sendNumeric(fd, 404, c->nick, target + " :Cannot send to channel");
			return;
		}
		srv.broadcastToChannel(target, fd, line);
	}
	else
	{
		int tfd = srv.fdByNick(target);
		if (tfd < 0)
		{
			srv.sendNumeric(fd, 401, c->nick, target + " :No such nick");
			return;
		}
		srv.sendToClient(tfd, line);
	}
}

static void cmdQUIT(Server &srv, int fd, const Message &msg)
{
	(void)msg;
	srv.disconnectClient(fd, "Client quit");
}

void handleCommand(Server &srv, int fd, const Message &msg)
{
	if (msg.command == "CAP")
		cmdCAP(srv, fd, msg);
	else if (msg.command == "PASS")
		cmdPASS(srv, fd, msg);
	else if (msg.command == "NICK")
		cmdNICK(srv, fd, msg);
	else if (msg.command == "USER")
		cmdUSER(srv, fd, msg);
	else if (msg.command == "PING")
		cmdPING(srv, fd, msg);
	else if (msg.command == "JOIN")
		cmdJOIN(srv, fd, msg);
	else if (msg.command == "PART")
		cmdPART(srv, fd, msg);
	else if (msg.command == "TOPIC")
		cmdTOPIC(srv, fd, msg);
	else if (msg.command == "INVITE")
		cmdINVITE(srv, fd, msg);
	else if (msg.command == "KICK")
		cmdKICK(srv, fd, msg);
	else if (msg.command == "MODE")
		cmdMODE(srv, fd, msg);
	else if (msg.command == "PRIVMSG")
		cmdPRIVMSG(srv, fd, msg);
	else if (msg.command == "QUIT")
		cmdQUIT(srv, fd, msg);
	else
	{
		Client *c = srv.getClient(fd);
		std::string target = (c && c->hasNick) ? c->nick : "*";
		srv.sendNumeric(fd, 421, target, msg.command + " :Unknown command");
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:35 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:37:03 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"
#include <iostream>
#include <cstdlib>

static bool isNumber(const char *s)
{
	if (!s || !*s) return false;
	for (int i = 0; s[i]; ++i)
		if (s[i] < '0' || s[i] > '9') return false;
	return true;
}

int main(int argc, char **argv)
{
	if (argc != 3)
	{
		std::cerr << "Usage: ./ircserv <port> <password>\n";
		return 1;
	}

	if (!isNumber(argv[1]))
	{
		std::cerr << "Error: port must be numeric\n";
		return 1;
	}

	int port = std::atoi(argv[1]);
	if (port <= 0 || port > 65535)
	{
		std::cerr << "Error: invalid port\n";
		return 1;
	}

	std::string password = argv[2];
	if (password.empty())
	{
		std::cerr << "Error: password must not be empty\n";
		return 1;
	}

	try
	{
		Server srv(port, password);
		srv.run();
	}
	catch (const std::exception &e)
	{
		std::cerr << "Fatal: " << e.what() << "\n";
		return 1;
	}

	return 0;
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Message.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha>                        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:32 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/07 02:16:04 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Message.hpp"
#include <cctype>
#include <sstream>

Message::Message() : hasTrailing(false) {}

std::string Message::trim(const std::string &s)
{
	std::string::size_type b = 0;
	while (b < s.size() && (s[b] == ' ' || s[b] == '\t'))
		b++;
	std::string::size_type e = s.size();
	while (e > b && (s[e - 1] == ' ' || s[e - 1] == '\t'))
		e--;
	return s.substr(b, e - b);
}

std::string Message::toUpper(const std::string &s)
{
	std::string out = s;
	for (std::string::size_type i = 0; i < out.size(); i++)
		out[i] = (char)std::toupper((unsigned char)out[i]);
	return out;
}

Message Message::parse(const std::string &line)
{
	Message m;
	m.raw = line;

	std::string s = trim(line);
	if (s.empty())
		return m;
	if (s[0] == ':')
	{
		std::string::size_type sp = s.find(' ');
		if (sp == std::string::npos)
			return m;
		s = trim(s.substr(sp + 1));
		if (s.empty())
			return m;
	}

	std::string::size_type trailPos = s.find(" :");
	if (trailPos != std::string::npos)
	{
		m.hasTrailing = true;
		m.trailing = s.substr(trailPos + 2);
		s = trim(s.substr(0, trailPos));
	}

	std::istringstream iss(s);
	std::string cmd;
	if (!(iss >> cmd))
		return m;

	m.command = toUpper(cmd);

	std::string p;
	while (iss >> p)
		m.params.push_back(p);

	return m;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Server.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mabou-ha <mabou-ha@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/12/28 13:05:37 by mabou-ha          #+#    #+#             */
/*   Updated: 2026/01/08 20:11:10 by mabou-ha         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Server.hpp"
#include "Handlers.hpp"

#include <iostream>
#include <sstream>
#include <stdexcept>
#include <cstring>
#include <cerrno>
#include <csignal>

#include <unistd.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/socket.h>

static std::string itos(int x)
{
	std::ostringstream oss;
	oss << x;
	return oss.str();
}

Server::Server(int port, const std::string &password)
	: port_(port), password_(password), listenFd_(-1), running_(true), serverName_("ircserv")
{
	std::signal(SIGPIPE, SIG_IGN);
	setupListenSocket();
}

Server::~Server()
{
	if (listenFd_ != -1)
		close(listenFd_);

	for (std::map<int, Client>::iterator it = clients_.begin(); it != clients_.end(); ++it)
		close(it->first);
}

const std::string& Server::getPassword() const { return password_; }
const std::string& Server::getServerName() const { return serverName_; }

void Server::setNonBlocking(int fd)
{
	int flags = fcntl(fd, F_GETFL, 0);
	if (flags < 0) 
		throw std::runtime_error("fcntl(F_GETFL) failed");
	if (fcntl(fd, F_SETFL, flags | O_NONBLOCK) < 0)
		throw std::runtime_error("fcntl(F_SETFL, O_NONBLOCK) failed");
}

void Server::setupListenSocket()
{
	listenFd_ = socket(AF_INET, SOCK_STREAM, 0);
	if (listenFd_ < 0) 
		throw std::runtime_error("socket() failed");

	int yes = 1;
	if (setsockopt(listenFd_, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) < 0)
		throw std::runtime_error("setsockopt(SO_REUSEADDR) failed");

	sockaddr_in addr;
	std::memset(&addr, 0, sizeof(addr));
	addr.sin_family = AF_INET;
	addr.sin_addr.s_addr = htonl(INADDR_ANY);
	addr.sin_port = htons((unsigned short)port_);

	if (bind(listenFd_, (sockaddr*)&addr, sizeof(addr)) < 0)
		throw std::runtime_error("bind() failed");

	if (listen(listenFd_, 128) < 0)
		throw std::runtime_error("listen() failed");

	setNonBlocking(listenFd_);
}

void Server::buildPollFds(std::vector<struct pollfd> &pfds)
{
	pfds.clear();

	pollfd p;
	p.fd = listenFd_;
	p.events = POLLIN;
	p.revents = 0;
	pfds.push_back(p);

	for (std::map<int, Client>::iterator it = clients_.begin(); it != clients_.end(); ++it)
	{
		pollfd c;
		c.fd = it->first;
		c.events = POLLIN;
		if (it->second.wantsWrite())
			c.events |= POLLOUT;
		c.revents = 0;
		pfds.push_back(c);
	}
}

void Server::run()
{
	while (running_)
	{
		std::vector<pollfd> pfds;
		buildPollFds(pfds);

		int ret = poll(&pfds[0], pfds.size(), 1000);
		if (ret < 0)
		{
			if (errno == EINTR) continue;
			continue;
		}

		for (std::vector<pollfd>::iterator it = pfds.begin(); it != pfds.end(); ++it)
		{
			if (it->fd == listenFd_)
			{
				if (it->revents & POLLIN)
					handleAccept();
			}
			else
			{
				int fd = it->fd;

				if (it->revents & (POLLHUP | POLLERR | POLLNVAL))
				{
					disconnectClient(fd, "Connection closed");
					continue;
				}
				if (it->revents & POLLIN)
					handleClientRead(fd);
				if (it->revents & POLLOUT)
					handleClientWrite(fd);
			}
		}
	}
}

void Server::handleAccept()
{
	while (true)
	{
		sockaddr_in addr;
		socklen_t len = sizeof(addr);
		int cfd = accept(listenFd_, (sockaddr*)&addr, &len);
		if (cfd < 0)
		{
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				break;
			break;
		}

		setNonBlocking(cfd);

		std::string host = inet_ntoa(addr.sin_addr);
		clients_.insert(std::make_pair(cfd, Client(cfd, host)));
	}
}

Client* Server::getClient(int fd)
{
	std::map<int, Client>::iterator it = clients_.find(fd);
	if (it == clients_.end())
		return 0;
	return &it->second;
}

Channel* Server::getChannel(const std::string &name)
{
	std::map<std::string, Channel>::iterator it = channels_.find(name);
	if (it == channels_.end())
		return 0;
	return &it->second;
}

Channel* Server::getOrCreateChannel(const std::string &name)
{
	Channel *ch = getChannel(name);
	if (ch) 
		return ch;

	channels_.insert(std::make_pair(name, Channel(name)));
	return getChannel(name);
}

void Server::eraseChannel(const std::string &name)
{
	channels_.erase(name);
}

bool Server::nickExists(const std::string &nick) const
{
	for (std::map<int, Client>::const_iterator it = clients_.begin(); it != clients_.end(); ++it)
	{
		if (it->second.hasNick && it->second.nick == nick)
			return true;
	}
	return false;
}

int Server::fdByNick(const std::string &nick) const
{
	for (std::map<int, Client>::const_iterator it = clients_.begin(); it != clients_.end(); ++it)
	{
		if (it->second.hasNick && it->second.nick == nick)
			return it->first;
	}
	return -1;
}

void Server::handleClientRead(int fd)
{
	Client *c = getClient(fd);
	if (!c) return;

	char buf[4096];

	while (true)
	{
		ssize_t n = recv(fd, buf, sizeof(buf), 0);
		if (n == 0)
		{
			disconnectClient(fd, "Client quit");
			return;
		}
		if (n < 0)
		{
			if (errno == EAGAIN || errno == EWOULDBLOCK)
				break;
			disconnectClient(fd, "Read error");
			return;
		}

		c->inbuf.append(buf, buf + n);

		while (true)
		{
			std::string::size_type pos = c->inbuf.find('\n');
			if (pos == std::string::npos)
				break;
		
			std::string line = c->inbuf.substr(0, pos);
			c->inbuf.erase(0, pos + 1);
			if (!line.empty() && line[line.size() - 1] == '\r')
				line.erase(line.size() - 1);
		
			if (!line.empty())
				processLine(fd, line);
		}

	}
}

void Server::handleClientWrite(int fd)
{
	Client *c = getClient(fd);
	if (!c) return;

	while (!c->outbuf.empty())
	{
		ssize_t n = send(fd, c->outbuf.c_str(), c->outbuf.size(), 0);
		if (n > 0)
		{
			c->outbuf.erase(0, (std::string::size_type)n);
			continue;
		}
		if (n < 0 && (errno == EAGAIN || errno == EWOULDBLOCK))
			return;

		disconnectClient(fd, "Write error");
		return;
	}
}

void Server::processLine(int fd, const std::string &line)
{
	Message msg = Message::parse(line);
	if (msg.command.empty())
		return;

	handleCommand(*this, fd, msg);
}

void Server::sendToClient(int fd, const std::string &msg)
{
	Client *c = getClient(fd);
	if (!c)
		return;
	c->queue(msg);
}

void Server::sendNumeric(int fd, int code, const std::string &target, const std::string &text)
{
	std::string c = itos(code);
	while (c.size() < 3) c = "0" + c;

	std::string line = ":" + serverName_ + " " + c + " " + target + " :" + text + "\r\n";
	sendToClient(fd, line);
}

void Server::broadcastToChannel(const std::string &chan, int exceptFd, const std::string &msg)
{
	Channel *ch = getChannel(chan);
	if (!ch) return;

	for (std::set<int>::iterator it = ch->members.begin(); it != ch->members.end(); ++it)
	{
		if (*it == exceptFd) continue;
		sendToClient(*it, msg);
	}
}

void Server::disconnectClient(int fd, const std::string &reason)
{
	Client *c = getClient(fd);

	if (c)
	{
		for (std::set<std::string>::iterator it = c->channels.begin(); it != c->channels.end(); ++it)
		{
			Channel *ch = getChannel(*it);
			if (ch)
			{
				ch->removeMember(fd);
				if (ch->members.empty())
					eraseChannel(ch->name);
			}
		}
		c->channels.clear();
	}
	std::string err = "ERROR :" + reason + "\r\n";
	::send(fd, err.c_str(), err.size(), 0);

	close(fd);
	clients_.erase(fd);
}
